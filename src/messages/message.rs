use std::{borrow::Cow, fmt};

use serde::{Deserialize, Serialize};
use serde_json::Value;
use typed_builder::TypedBuilder;

/// Represents the role of a message sender in a conversation.
///
/// This enum distinguishes between messages sent by the user and
/// messages generated by the language model.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum Role {
    User,
    Model,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, TypedBuilder)]
pub struct Content<'a> {
    #[builder(setter(into))]
    pub role: Role,
    #[builder(default, setter(transform = |v: impl IntoIterator<Item = impl Into<Part<'a>>>|
        v.into_iter().map(Into::into).collect::<Vec<_>>()
    ))]
    pub parts: Vec<Part<'a>>,
}

impl<'a> Content<'a> {
    #[must_use]
    pub fn parts(&self) -> &Vec<Part<'a>> {
        &self.parts
    }

    pub fn parts_mut(&mut self) -> &mut Vec<Part<'a>> {
        &mut self.parts
    }

    pub fn push<T: Into<Part<'a>>>(&mut self, part: T) {
        self.parts.push(part.into());
    }

    #[must_use]
    pub fn as_user(&self) -> Option<&Self> {
        if self.role == Role::User {
            Some(self)
        } else {
            None
        }
    }

    #[must_use]
    pub fn expect_user(&self) -> &Self {
        self.as_user().expect("Expected Content to be User")
    }

    #[must_use]
    pub fn as_model(&self) -> Option<&Self> {
        if self.role == Role::Model {
            Some(self)
        } else {
            None
        }
    }

    #[must_use]
    pub fn expect_model(&self) -> &Self {
        self.as_model().expect("Expected Content to be Model")
    }

    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.parts.is_empty()
    }

    pub fn iter(&self) -> impl Iterator<Item = &Part<'a>> {
        self.parts.iter()
    }

    #[must_use]
    pub fn to_owned(&self) -> Content<'static> {
        Content {
            role: self.role.clone(),
            parts: self.parts.iter().map(Part::to_owned).collect(),
        }
    }
}

impl<'a> IntoIterator for Content<'a> {
    type Item = Part<'a>;
    type IntoIter = std::vec::IntoIter<Self::Item>;

    fn into_iter(self) -> Self::IntoIter {
        self.parts.into_iter()
    }
}

impl<'a> FromIterator<Part<'a>> for Content<'a> {
    fn from_iter<T: IntoIterator<Item = Part<'a>>>(iter: T) -> Self {
        Self::builder().role(Role::User).parts(iter).build()
    }
}

impl<'a> From<&'a str> for Content<'a> {
    fn from(value: &'a str) -> Self {
        Content::builder()
            .role(Role::User)
            .parts(vec![Part::from(value)])
            .build()
    }
}

impl<'a> From<String> for Content<'a> {
    fn from(value: String) -> Self {
        Content::builder()
            .role(Role::User)
            .parts(vec![Part::from(value)])
            .build()
    }
}

impl<'a> Extend<Part<'a>> for Content<'a> {
    fn extend<T: IntoIterator<Item = Part<'a>>>(&mut self, iter: T) {
        self.parts_mut().extend(iter);
    }
}

/// Part
///
/// A datatype containing media that is part of a multi-part Content message.
/// A Part consists of data which has an associated datatype. A Part can only contain one of the accepted types in Part.data.
/// A Part must have a fixed IANA MIME type identifying the type and subtype of the media if the inlineData field is filled with raw bytes.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub enum Part<'a> {
    /// Inline text.
    Text(Text<'a>),
    /// Inline media bytes.
    InlineData(Blob<'a>),
    /// A predicted FunctionCall returned from the model that contains a string representing the FunctionDeclaration.name with the arguments and their values.
    FunctionCall(FunctionCall),
    /// The result output of a FunctionCall that contains a string representing the FunctionDeclaration.name and a structured JSON object containing any output from the function is used as context to the model.
    FunctionResponse(FunctionResponse),
    /// URI based data.
    FileData(FileData),
}

impl<'a> Part<'a> {
    /// If the `Part` is a `Text` variant, return `Some(Text)`, otherwise return `None`.
    #[must_use]
    pub fn as_text(&self) -> Option<&Text> {
        match self {
            Part::Text(text) => Some(text),
            _ => None,
        }
    }

    #[must_use]
    pub fn expect_text(&self) -> &Text {
        self.as_text().expect("Expected Part to be Text")
    }
    /// If the `Part` is a `InlineData` variant, return `Some(InlineData)`, otherwise return `None`.
    #[must_use]
    pub fn as_inline_data(&self) -> Option<&Blob> {
        match self {
            Part::InlineData(inline_data) => Some(inline_data),
            _ => None,
        }
    }
    #[must_use]
    pub fn expect_inline_data(&self) -> &Blob {
        self.as_inline_data()
            .expect("Expected Part to be InlineData")
    }
    /// If the `Part` is a `FunctionCall` variant, return `Some(FunctionCall)`, otherwise return `None`.
    #[must_use]
    pub fn as_function_call(&self) -> Option<&FunctionCall> {
        match self {
            Part::FunctionCall(function_call) => Some(function_call),
            _ => None,
        }
    }
    #[must_use]
    pub fn expect_function_call(&self) -> &FunctionCall {
        self.as_function_call()
            .expect("Expected Part to be FunctionCall")
    }
    /// If the `Part` is a `FunctionResponse` variant, return `Some(FunctionResponse)`, otherwise return `None`.
    #[must_use]
    pub fn as_function_response(&self) -> Option<&FunctionResponse> {
        match self {
            Part::FunctionResponse(function_response) => Some(function_response),
            _ => None,
        }
    }
    #[must_use]
    pub fn expect_function_response(&self) -> &FunctionResponse {
        self.as_function_response()
            .expect("Expected Part to be FunctionResponse")
    }
    /// If the `Part` is a `FileData` variant, return `Some(FileData)`, otherwise return `None`.
    #[must_use]
    pub fn as_file_data(&self) -> Option<&FileData> {
        match self {
            Part::FileData(file_data) => Some(file_data),
            _ => None,
        }
    }
    #[must_use]
    pub fn expect_file_data(&self) -> &FileData {
        self.as_file_data().expect("Expected Part to be FileData")
    }

    #[must_use]
    pub fn to_owned(&self) -> Part<'static> {
        match self {
            Part::Text(text) => Part::Text(Text(Cow::Owned(text.0.to_string()))),
            Part::InlineData(blob) => Part::InlineData(Blob {
                mime_type: blob.mime_type.clone(),
                data: Cow::Owned(blob.data.to_string()),
            }),
            Part::FunctionCall(func_call) => Part::FunctionCall(func_call.clone()),
            Part::FunctionResponse(func_response) => Part::FunctionResponse(func_response.clone()),
            Part::FileData(file_data) => Part::FileData(file_data.clone()),
        }
    }
}

impl<'a> From<String> for Part<'a> {
    fn from(value: String) -> Self {
        Part::Text(value.into())
    }
}

impl<'a> From<&'a str> for Part<'a> {
    fn from(value: &'a str) -> Self {
        Part::Text(value.into())
    }
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
pub struct Text<'a>(pub Cow<'a, str>);

impl<'a> From<&'a str> for Text<'a> {
    fn from(value: &'a str) -> Self {
        Self(Cow::Borrowed(value))
    }
}

impl<'a> From<String> for Text<'a> {
    fn from(value: String) -> Self {
        Self(Cow::Owned(value))
    }
}

impl<'a> fmt::Display for Text<'a> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl<'a> From<Text<'a>> for Part<'a> {
    fn from(text: Text<'a>) -> Self {
        Self::Text(text)
    }
}

impl<'a> From<Blob<'a>> for Part<'a> {
    fn from(blob: Blob<'a>) -> Self {
        Self::InlineData(blob)
    }
}

impl<'a> From<FunctionCall> for Part<'a> {
    fn from(function_call: FunctionCall) -> Self {
        Self::FunctionCall(function_call)
    }
}

impl<'a> From<FunctionResponse> for Part<'a> {
    fn from(function_response: FunctionResponse) -> Self {
        Self::FunctionResponse(function_response)
    }
}

impl<'a> From<FileData> for Part<'a> {
    fn from(file_data: FileData) -> Self {
        Self::FileData(file_data)
    }
}

/// Blob
///
/// Raw media bytes.
/// Text should not be sent as raw bytes, use the 'text' field.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct Blob<'a> {
    /// The IANA standard MIME type of the source data. Examples: - image/png - image/jpeg
    /// If an unsupported MIME type is provided, an error will be returned.
    /// For a complete list of supported types, see Supported file formats.
    pub mime_type: String,
    /// Raw bytes for media formats.
    /// A base64-encoded string.
    pub data: Cow<'a, str>,
}

/// FunctionCall
///
/// A predicted FunctionCall returned from the model that contains a string representing the FunctionDeclaration.name with the arguments and their values.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct FunctionCall {
    /// Required. The name of the function to call. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
    pub name: String,
    /// Optional. The function parameters and values in JSON object format.
    pub args: Option<Value>,
}

/// FunctionResponse
///
/// The result output from a FunctionCall that contains a string representing the FunctionDeclaration.name and a structured JSON object containing any output from the function is used as context to the model. This should contain the result of aFunctionCall made based on model prediction.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct FunctionResponse {
    /// Required. The name of the function to call. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
    pub name: String,
    /// Required. The function response in JSON object format.
    pub response: Value,
}

/// FileData
///
/// URI based data.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct FileData {
    /// Optional. The IANA standard MIME type of the source data.
    pub mime_type: Option<String>,
    /// Required. URI.
    pub file_uri: String,
}

#[cfg(test)]
mod tests {
    use serde_json::json;

    use super::*;

    #[cfg(target_arch = "wasm32")]
    use wasm_bindgen_test::*;

    // #[cfg(target_arch = "wasm32")]
    // wasm_bindgen_test_configure!(run_in_browser);

    #[test]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
    fn test_role_serialization() {
        let user_role = Role::User;
        let user_json = serde_json::to_string(&user_role).unwrap();
        assert_eq!(user_json, "\"user\"");

        let model_role = Role::Model;
        let model_json = serde_json::to_string(&model_role).unwrap();
        assert_eq!(model_json, "\"model\"");
    }

    #[test]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
    fn test_role_deserialization() {
        let user_json = "\"user\"";
        let user_role: Role = serde_json::from_str(user_json).unwrap();
        assert_eq!(user_role, Role::User);

        let model_json = "\"model\"";
        let model_role: Role = serde_json::from_str(model_json).unwrap();
        assert_eq!(model_role, Role::Model);
    }

    #[test]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
    fn test_content_serialization() {
        let content = Content::builder()
            .role(Role::User)
            .parts(vec![Part::Text(Text::from("Hello, world!"))])
            .build();
        let json_content = serde_json::to_string(&content).unwrap();
        dbg!(serde_json::to_string(&content).unwrap());
        assert_eq!(
            json_content,
            r#"{"role":"user","parts":[{"text":"Hello, world!"}]}"#
        );
    }

    #[test]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
    fn test_content_deserialization() {
        let json_content = r#"{"parts":[{"text":"Hello, world!"}],"role":"user"}"#;
        let content: Content = serde_json::from_str(json_content).unwrap();
        assert_eq!(
            content,
            Content::builder()
                .role(Role::User)
                .parts(vec![Part::Text(Text::from("Hello, world!"))])
                .build()
        );
    }

    #[test]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
    fn test_part_serialization() {
        let part = Part::Text(Text::from("Hello, world!"));
        let json_part = serde_json::to_string(&part).unwrap();
        assert_eq!(json_part, r#"{"text":"Hello, world!"}"#);
    }

    #[test]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
    fn test_part_deserialization() {
        let json_part = r#"{"text":"Hello, world!"}"#;
        let part: Part = serde_json::from_str(json_part).unwrap();
        assert_eq!(part, Part::Text(Text::from("Hello, world!")));
    }

    #[test]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
    fn test_function_call_serialization() {
        let function_call = FunctionCall {
            name: "my_function".to_string(),
            args: Some(json!({"arg1": "value1", "arg2": 42})),
        };
        let json_function_call = serde_json::to_string(&function_call).unwrap();
        assert_eq!(
            json_function_call,
            r#"{"name":"my_function","args":{"arg1":"value1","arg2":42}}"#
        );
    }

    #[test]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
    fn test_function_call_deserialization() {
        let json_function_call = r#"{"name":"my_function","args":{"arg1":"value1","arg2":42}}"#;
        let function_call: FunctionCall = serde_json::from_str(json_function_call).unwrap();
        assert_eq!(
            function_call,
            FunctionCall {
                name: "my_function".to_string(),
                args: Some(json!({"arg1": "value1", "arg2": 42})),
            }
        );
    }

    #[test]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
    fn test_function_response_serialization() {
        let function_response = FunctionResponse {
            name: "my_function".to_string(),
            response: json!({"result": "success"}),
        };
        let json_function_response = serde_json::to_string(&function_response).unwrap();
        assert_eq!(
            json_function_response,
            r#"{"name":"my_function","response":{"result":"success"}}"#
        );
    }

    #[test]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
    fn test_function_response_deserialization() {
        let json_function_response = r#"{"name":"my_function","response":{"result":"success"}}"#;
        let function_response: FunctionResponse =
            serde_json::from_str(json_function_response).unwrap();
        assert_eq!(
            function_response,
            FunctionResponse {
                name: "my_function".to_string(),
                response: json!({"result": "success"}),
            }
        );
    }

    #[test]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen_test)]
    fn test_deserialize_content_with_function_call() {
        let input = json!({
            "parts": [
            {
                "functionCall": {
                    "name": "test_function",
                    "args": {
                        "x": 1,
                        "y": 2
                    }
                }
            }
            ],
            "role": "model"
        });

        let expected = Content::builder()
            .role(Role::Model)
            .parts(vec![Part::FunctionCall(FunctionCall {
                name: "test_function".to_string(),
                args: Some(json!({
                    "x": 1,
                    "y": 2
                })),
            })])
            .build();
        let result: Content = serde_json::from_value(input).unwrap();
        assert_eq!(result, expected);
    }
}
